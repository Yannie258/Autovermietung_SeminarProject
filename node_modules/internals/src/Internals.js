const __internalsError__ = 'The `internals` property was not instanciated!';
const __protectedError__ = '`target` is not protected!';

class Internals {
    static protect (target) {
        if (target[Internals.symbols.protected] === true)
            return true;

        const ctor = target.constructor;

        if(Reflect.defineProperty(ctor, Internals.symbols.internals, {
            value: {},
            writable: false,
            configurable: false,
            enumerable: false
        })) return (ctor[Internals.symbols.protected] = true);

        return false;
    }

    static defineSymbol (ctor, propertyKey, symbol) {
        if(!Reflect.has(ctor, Internals.symbols.internals))
            throw new Error(__internalsError__);

        const internals = ctor[Internals.symbols.internals];

        if (Reflect.defineProperty(internals, propertyKey, {
            value: symbol || Symbol(propertyKey),
            writable: false,
            configurable: false,
            enumerable: false
        })) return internals[propertyKey];

        return null;
    }

    static getSymbol (ctor, propertyKey) {
        if(!Reflect.has(ctor, Internals.symbols.internals))
            throw new Error(__internalsError__);

        const internals = ctor[Internals.symbols.internals];

        return internals[propertyKey] || null;
    }

    static hasSymbol (ctor, propertyKey) {
        if(!Reflect.has(ctor, Internals.symbols.internals))
            throw new Error(__internalsError__);

        const internals = ctor[Internals.symbols.internals];

        return Reflect.has(internals, propertyKey);
    }

    static removeSymbol (ctor, propertyKey) {
        if(!Reflect.has(ctor, Internals.symbols.internals))
            throw new Error(__internalsError__);

        const internals = ctor[Internals.symbols.internals];

        return Reflect.delete(internals, propertyKey);
    }

    static define (target, propertyKey, attributes = {}) {
        if (target[Internals.symbols.protected] !== true)
            throw new Error(__protectedError__);

        const ctor = target.constructor;
        const propertySymbol = Internals.defineSymbol(ctor, propertyKey);

        return Reflect.defineProperty(target, propertySymbol, attributes);
    }

    static set (target, propertyKey, propertyValue) {
        if (target[Internals.symbols.protected] !== true)
            throw new Error(__protectedError__);

        const ctor = target.constructor;
        const propertySymbol = Internals.getSymbol(ctor, propertyKey);

        if (propertySymbol === null) {
            return Internals.define(target, propertyKey, {value: propertyValue});
        }

        return Reflect.set(target, propertySymbol, propertyValue);
    }

    static get (target, propertyKey) {
        if (target[Internals.symbols.protected] !== true)
            throw new Error(__protectedError__);

        const ctor = target.constructor;
        const propertySymbol = Internals.getSymbol(ctor, propertyKey);

        return Reflect.get(target, propertySymbol);
    }

    static has (target, propertyKey) {
        if (target[Internals.symbols.protected] !== true)
            throw new Error(__protectedError__);

        const ctor = target.constructor;
        const propertySymbol = Internals.getSymbol(ctor, propertyKey);

        return Reflect.has(target, propertySymbol);
    }

    static remove (target, propertyKey) {
        if (target[Internals.symbols.protected] !== true)
            throw new Error(__protectedError__);

        const ctor = target.constructor;
        const propertySymbol = Internals.getSymbol(ctor, propertyKey);
        const protperty = target[propertySymbol];

        protperty.writable = true;
        protperty.configurable = true;
        protperty.enumerable = false;
        protperty.value = undefined;

        return Reflect.deleteProperty(target, propertySymbol);
    }

    static internal (target, propertyKey, descriptor) {
        Internals.define(target, propertyKey, Object.create(descriptor));

        descriptor.writable = true;
        descriptor.configurable = true;
        descriptor.enumerable = false;
        descriptor.value = undefined;

        return Reflect.deleteProperty(target, propertyKey);
    }
}

Internals.symbols = {
    internals: Symbol('internals'),
    protected: Symbol('protected')
};

export default Internals;
