'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fetch = _interopDefault(require('cross-fetch'));
var queryString = _interopDefault(require('query-string'));
var FormData = _interopDefault(require('form-data'));

// from https://github.com/jonbern/fetch-retry
// and https://github.com/jonbern/fetch-retry/pull/27
var transport = (url, options) => {
  let retries = 3;
  let retryDelay = 1000;
  let retryOn = [429, 502, 503, 504];
  if (options && options.retries !== undefined) {
    if (isPositiveInteger(options.retries)) {
      retries = options.retries;
    } else {
      throw new ArgumentError('retries must be a positive integer')
    }
  }

  if (options && options.retryDelay !== undefined) {
    if (
      isPositiveInteger(options.retryDelay) ||
      typeof options.retryDelay === 'function'
    ) {
      retryDelay = options.retryDelay;
    } else {
      throw new ArgumentError(
        'retryDelay must be a positive integer or a function returning a positive integer'
      )
    }
  }

  if (options && options.retryOn) {
    if (
      Array.isArray(options.retryOn) ||
      typeof options.retryOn === 'function'
    ) {
      retryOn = options.retryOn;
    } else {
      throw new ArgumentError('retryOn property expects an array or function')
    }
  }

  return new Promise(function (resolve, reject) {
    const wrappedFetch = function (attempt) {
      fetch(url, options)
        .then(function (response) {
          if (
            Array.isArray(retryOn) &&
            retryOn.indexOf(response.status) === -1
          ) {
            resolve(response);
            return
          }
          if (typeof retryOn === 'function') {
            if (retryOn(attempt, null, response)) {
              retry(attempt, null, response);
              return
            }
            resolve(response);
            return
          }
          if (attempt < retries) {
            retry(attempt, null, response);
            return
          }
          resolve(response);
        })
        .catch(function (error) {
          if (typeof retryOn === 'function') {
            if (retryOn(attempt, error, null)) {
              retry(attempt, error, null);
              return
            }
            reject(error);
            return
          }
          if (attempt < retries) {
            retry(attempt, error, null);
            return
          }
          reject(error);
        });
    };

    function retry (attempt, error, response) {
      const delay =
        typeof retryDelay === 'function'
          ? retryDelay(attempt, error, response)
          : retryDelay;
      setTimeout(function () {
        wrappedFetch(++attempt);
      }, delay);
    }

    wrappedFetch(0);
  })
};

function isPositiveInteger (value) {
  return Number.isInteger(value) && value >= 0
}

function ArgumentError (message) {
  this.name = 'ArgumentError';
  this.message = message;
}

/**
 * ### Memberships
 *
 * #### Roles
 *
 * - `rokka.memberships.ROLES.READ` - read-only access
 * - `rokka.memberships.ROLES.WRITE` - read-write access
 * - `rokka.memberships.ROLES.UPLOAD` - upload-only access
 * - `rokka.memberships.ROLES.ADMIN` - administrative access
 *
 * @module memberships
 */
var memberships = state => {
  const ROLES = {
    READ: 'read',
    WRITE: 'write',
    UPLOAD: 'upload',
    ADMIN: 'admin'
  };
  const memberships = { ROLES };

  /**
   * Add a member to an organization.
   *
   * ```js
   * rokka.memberships.create('myorg', '613547f8-e26d-48f6-8a6a-552c18b1a290', [rokka.memberships.ROLES.WRITE])
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}        organization name
   * @param  {string}        userId       UUID of user to add to the organization
   * @param  {string|array}  roles        user roles (`rokka.memberships.ROLES`)
   * @return {Promise}
   */
  memberships.create = (organization, userId, roles) => {
    if (typeof roles === 'string') {
      roles = [roles];
    }

    roles.forEach(role => {
      if (
        Object.keys(ROLES)
          .map(key => ROLES[key])
          .indexOf(role) === -1
      ) {
        return Promise.reject(new Error(`Invalid role "${role}"`))
      }
    });

    const path = `organizations/${organization}/memberships/${userId}`;

    return state.request('PUT', path, { roles: roles })
  };

  /**
   * Delete a member in an organization.
   *
   * ```js
   * rokka.memberships.delete('myorg', '613547f8-e26d-48f6-8a6a-552c18b1a290')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}        organization name
   * @param  {string}        userId       UUID of user to add to the organization
   * @return {Promise}
   */
  memberships.delete = (organization, userId) => {
    const path = `organizations/${organization}/memberships/${userId}`;

    return state.request('DELETE', path)
  };

  /**
   * Create a user and membership associated to this organization.
   *
   * ```js
   * rokka.memberships.createWithNewUser('myorg', [rokka.memberships.ROLES.READ])
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}        organization name
   * @param  {array}  roles        user roles (`rokka.memberships.ROLES`)
   * @return {Promise}
   */
  memberships.createWithNewUser = (organization, roles) => {
    roles.forEach(role => {
      if (
        Object.keys(ROLES)
          .map(key => ROLES[key])
          .indexOf(role) === -1
      ) {
        return Promise.reject(new Error(`Invalid role "${role}"`))
      }
    });

    const path = `organizations/${organization}/memberships`;

    return state.request('POST', path, { roles: roles })
  };

  /**
   * Lists members in an organization.
   *
   * ```js
   * rokka.memberships.list('myorg')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}        organization name
   * @return {Promise}
   */
  memberships.list = organization => {
    const path = `organizations/${organization}/memberships`;

    return state.request('GET', path)
  };

  /**
   * Get info of a member in an organization.
   *
   * ```js
   * rokka.memberships.get('myorg',userId)
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}        organization name
   * @param  {string}        userId
   * @return {Promise}
   */
  memberships.get = (organization, userId) => {
    const path = `organizations/${organization}/memberships/${userId}`;

    return state.request('GET', path)
  };

  return {
    memberships
  }
};

/**
 * ### Operations
 *
 * #### Available operations
 *
 * - `rokka.operations.resize(width, height, options = {})`
 * - `rokka.operations.autorotate(options = {})`
 * - `rokka.operations.rotate(angle, options = {})`
 * - `rokka.operations.dropshadow(options = {})`
 * - `rokka.operations.trim(options = {})`
 * - `rokka.operations.crop(width, height, options = {})`
 * - `rokka.operations.noop()`
 * - `rokka.operations.composition(width, height, mode, options = {})`
 * - `rokka.operations.blur(sigma, radius)`
 *
 * Please refer to the
 * [rokka API documentation](https://rokka.io/documentation/references/operations.html)
 *
 * @module operations
 */
var operations = state => {
  const operations = {};

  operations.resize = (width, height, options = {}) => {
    options.width = width;
    options.height = height;

    return {
      name: 'resize',
      options
    }
  };

  operations.autorotate = (options = {}) => {
    return {
      name: 'autorotate',
      options
    }
  };

  operations.rotate = (angle, options = {}) => {
    options.angle = angle;

    return {
      name: 'rotate',
      options
    }
  };

  operations.dropshadow = (options = {}) => {
    return {
      name: 'dropshadow',
      options
    }
  };

  operations.trim = (options = {}) => {
    return {
      name: 'trim',
      options
    }
  };

  operations.crop = (width, height, options = {}) => {
    options.width = width;
    options.height = height;

    return {
      name: 'crop',
      options
    }
  };

  operations.noop = () => {
    return {
      name: 'noop'
    }
  };

  operations.composition = (width, height, mode, options = {}) => {
    options.width = width;
    options.height = height;
    options.mode = mode;

    return {
      name: 'composition',
      options
    }
  };

  operations.blur = (sigma, radius) => {
    const options = { sigma, radius };

    return {
      name: 'blur',
      options
    }
  };

  /**
   * Get a list of available stack operations.
   *
   * ```js
   * rokka.operations.list()
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @return {Promise}
   */
  operations.list = () => {
    return state.request('GET', 'operations', null, null, {
      noAuthHeaders: true
    })
  };

  return {
    operations
  }
};

/**
 * ### Organizations
 *
 * @module organizations
 */
var organizations = state => {
  const organizations = {};

  /**
   * Get a list of organizations.
   *
   * ```js
   * rokka.organizations.get('myorg')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  name organization
   * @return {Promise}
   */
  organizations.get = name => {
    return state.request('GET', `organizations/${name}`)
  };

  /**
   * Create an organization.
   *
   * ```js
   * rokka.organizations.create('myorg', 'billing@example.org', 'Organization Inc.')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  name         organization
   * @param  {string}  billingEmail email used for billing
   * @param  {string}  displayName  pretty name
   * @return {Promise}
   */
  organizations.create = (name, billingEmail, displayName) => {
    return state.request('PUT', `organizations/${name}`, {
      billing_email: billingEmail,
      display_name: displayName
    })
  };

  return {
    organizations
  }
};

/**
 * ### expressions
 *
 * @module expressions
 */
var expressions = state => {
  const expressions = {};

  expressions.default = (expression, options) => {
    return { expression, overrides: { options } }
  };

  return {
    expressions
  }
};

function stringifyOperations (operations) {
  operations = Array.isArray(operations) ? operations : [operations];

  return operations
    .map(operation => {
      const name = operation.name;
      const options = Object.keys(operation.options || {})
        .map(k => `${k}-${operation.options[k]}`)
        .join('-');

      if (!options) {
        return name
      }

      return `${name}-${options}`
    })
    .join('--')
}

function isStream (stream) {
  return (
    stream !== null &&
    typeof stream === 'object' &&
    typeof stream.pipe === 'function'
  )
}

/**
 * ### Render
 *
 * @module render
 */
var render = state => {
  const render = {};

  /**
   * Get URL for rendering an image.
   *
   * ```js
   * rokka.render.getUrl('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a', 'png', 'mystack')
   * ```
   *
   * @param  {string}       organization name
   * @param  {string}       hash         image hash
   * @param  {string}       format       image format: `jpg`, `png` or `gif`
   * @param  {string|array} [mixed]      optional stack name or an array of stack operation objects
   * @return {string}
   */
  render.getUrl = (organization, hash, format, mixed) => {
    const host = state.renderHost.replace('{organization}', organization);
    const mixedParam = Array.isArray(mixed)
      ? `dynamic/${stringifyOperations(mixed)}` // array of operations
      : mixed; // stack name
    const stack = mixedParam || 'dynamic/noop';

    return `${host}/${stack}/${hash}.${format}`
  };

  return {
    render
  }
};

/**
 * ### Source Images
 *
 * @module sourceimages
 */
var sourceimages = state => {
  const sourceimages = {
    meta: {}
  };

  /**
   * Get a list of source images.
   *
   * By default, listing sourceimages sorts them by created date descending.
   *
   * ```js
   * rokka.sourceimages.list('myorg')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * Searching for images can be achieved using the `search` parameter.
   * Supported are predefined fields like `height`, `name` etc. but also user metadata.
   * If you search for user metadata, the field name has to be prefixed with `user:TYPE`.
   * All fields are combined with an AND. OR/NOT is not possible.
   *
   * Example:
   *
   * ```js
   * const search = {
   *   'user:int:id': '42',
   *   'height': '64'
   * }
   * rokka.sourceimages.list('myorg', { search: search })
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * The search also supports range and wildcard queries.
   * Check out [the rokka documentation](https://rokka.io/documentation/references/searching-images.html) for more.
   *
   * Sorting works with user metadata as well and can be passed as either an array or as a
   * comma separated string.
   *
   * @authenticated
   * @param  {string} organization  name
   * @param  {Object} params Query string params (limit, offset, sort and search)
   * @return {Promise}
   */
  sourceimages.list = (
    organization,
    {
      limit = null,
      offset = null,
      sort = null,
      search = null,
      facets = null,
      deleted = null
    } = {}
  ) => {
    let queryParams = {};

    if (limit !== null) {
      queryParams.limit = limit;
    }
    if (offset !== null) {
      queryParams.offset = offset;
    }
    if (facets !== null) {
      queryParams.facets = facets;
    }
    if (deleted !== null) {
      queryParams.deleted = deleted;
    }

    if (sort !== null) {
      if (Array.isArray(sort)) {
        sort = sort.join(',');
      }
      queryParams.sort = sort;
    }
    if (search !== null) {
      queryParams = Object.assign(queryParams, search);
    }

    return state.request(
      'GET',
      `sourceimages/${organization}`,
      null,
      queryParams
    )
  };

  /**
   * Get information of a source image by hash.
   *
   * ```js
   * rokka.sourceimages.get('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  hash         image hash
   * @param  {Object}  queryParams  like {deleted: true}
   * @return {Promise}
   */
  sourceimages.get = (organization, hash, queryParams = {}) => {
    return state.request(
      'GET',
      `sourceimages/${organization}/${hash}`,
      null,
      queryParams
    )
  };

  /**
   * Get information of a source image by its binary hash.
   *
   * ```js
   * rokka.sourceimages.getWithBinaryHash('myorg', 'b23e17047329b417d3902dc1a5a7e158a3ee822a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  binaryHash   binary image hash
   * @return {Promise}
   */
  sourceimages.getWithBinaryHash = (organization, binaryHash) => {
    const queryParams = { binaryHash: binaryHash };

    return state.request(
      'GET',
      `sourceimages/${organization}`,
      null,
      queryParams
    )
  };

  /**
   * Download image by hash.
   *
   * ```js
   * rokka.sourceimages.download('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  hash         image hash
   * @return {Promise}
   */
  sourceimages.download = (organization, hash) => {
    return state.request('GET', `sourceimages/${organization}/${hash}/download`)
  };

  /**
   * Autolabels an image.
   *
   * You need to be a paying customer to be able to use this.
   *
   * ```js
   * rokka.sourceimages.autolabel('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  hash         image hash
   * @return {Promise}
   */
  sourceimages.autolabel = (organization, hash) => {
    return state.request(
      'POST',
      `sourceimages/${organization}/${hash}/autolabel`
    )
  };

  /**
   * Upload an image.
   *
   * ```js
   * const file = require('fs').createReadStream('picture.png');
   * rokka.sourceimages.create('myorg', 'picture.png', file)
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * With directly adding metadata:
   *
   * ```
   * rokka.sourceimages.create('myorg', 'picture.png', file, {'meta_user': {'foo': 'bar'}})
   * ```
   *
   * @authenticated
   * @param  {string} organization    name
   * @param  {string} fileName        file name
   * @param  {*}      binaryData      either a readable stream (in node.js only) or a binary string
   * @param  {Object} [metadata=null] optional, metadata to be added, either user or dynamic
   * @param  {{optimize_source: bool}} [options={}] Optional: only {optimize_source: true/false} yet, false is default
   * @return {Promise}
   */
  sourceimages.create = (
    organization,
    fileName,
    binaryData,
    metadata = null,
    options = {}
  ) => {
    const config = {
      multipart: true
    };

    return new Promise(resolve => {
      // Stream and Buffer are only supported by node.js and not browsers natively
      // We just asume that a browser based solution will provide the binaryData
      // of the image as String. But patches are welcome for stream alternatives
      // in browsers
      if (isStream(binaryData)) {
        const chunks = [];
        binaryData.on('data', chunk => chunks.push(chunk));
        binaryData.on('end', () => resolve(Buffer.concat(chunks)));
      } else {
        resolve(binaryData);
      }
    }).then(data => {
      const formData = {
        ...options
      };
      if (metadata !== null) {
        Object.keys(metadata).forEach(function (o) {
          const data = metadata[o];
          formData[o + '[0]'] =
            typeof data === 'string' ? data : JSON.stringify(data);
        });
      }
      const payload = {
        name: 'filedata',
        formData: formData,
        filename: fileName,
        contents: data
      };
      return state.request(
        'POST',
        `sourceimages/${organization}`,
        payload,
        null,
        config
      )
    })
  };

  /**
   * Upload an image by url.
   *
   * ```js
   * rokka.sourceimages.createByUrl('myorg', 'https://rokka.rokka.io/dynamic/f4d3f334ba90d2b4b00e82953fe0bf93e7ad9912.png')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * With directly adding metadata:
   *
   * ```
   * rokka.sourceimages.createByUrl('myorg',  'https://rokka.rokka.io/dynamic/f4d3f334ba90d2b4b00e82953fe0bf93e7ad9912.png', {'meta_user': {'foo': 'bar'}})
   * ```
   *
   * @authenticated
   * @param  {string} organization     name
   * @param  {string} url              The URL to the remote image
   * @param  {Object} [metadata=null]  optional, metadata to be added, either user or dynamic
   * @param  {{optimize_source: bool}} [options={}] Optional: only {optimize_source: true/false} yet, false is default
   * @return {Promise}
   */
  sourceimages.createByUrl = (
    organization,
    url,
    metadata = null,
    options = {}
  ) => {
    const config = {
      form: true
    };

    const formData = {
      'url[0]': url,
      ...options
    };
    if (metadata !== null) {
      Object.keys(metadata).forEach(function (o) {
        const data = metadata[o];
        formData[o + '[0]'] =
          typeof data === 'string' ? data : JSON.stringify(data);
      });
    }

    return state.request(
      'POST',
      `sourceimages/${organization}`,
      formData,
      null,
      config
    )
  };

  /**
   * Delete image by hash.
   *
   * ```js
   * rokka.sourceimages.delete('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  hash         image hash
   * @return {Promise}
   */
  sourceimages.delete = (organization, hash) => {
    return state.request('DELETE', `sourceimages/${organization}/${hash}`)
  };

  /**
   * Delete source images by its binary hash.
   *
   * ```js
   * rokka.sourceimages.deleteWithBinaryHash('myorg', 'b23e17047329b417d3902dc1a5a7e158a3ee822a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  binaryHash   binary image hash
   * @return {Promise}
   */
  sourceimages.deleteWithBinaryHash = (organization, binaryHash) => {
    const queryParams = { binaryHash: binaryHash };

    return state.request(
      'DELETE',
      `sourceimages/${organization}`,
      null,
      queryParams
    )
  };

  /**
   * Restore image by hash.
   *
   * ```js
   * rokka.sourceimages.restore('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  hash         image hash
   * @return {Promise}
   */
  sourceimages.restore = (organization, hash) => {
    return state.request('POST', `sourceimages/${organization}/${hash}/restore`)
  };

  /**
   * Copy image by hash to another org.
   *
   * ```js
   * rokka.sourceimages.copy('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a', 'anotherorg', true)
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization            the org the image is copied from
   * @param  {string}  hash                    image hash
   * @param  {string}  destinationOrganization the org the image is copied to
   * @param  {boolean} [overwrite=true]     if an existing image should be overwritten
   *
   * @return {Promise}
   */
  sourceimages.copy = (
    organization,
    hash,
    destinationOrganization,
    overwrite = true
  ) => {
    const headers = { Destination: destinationOrganization };
    if (!overwrite) {
      headers.Overwrite = 'F';
    }
    return state.request(
      'COPY',
      `sourceimages/${organization}/${hash}`,
      null,
      null,
      { headers }
    )
  };

  /**
   * ### Dynamic metadata
   *
   * See [the dynamic metadata documentation](https://rokka.io/documentation/references/dynamic-metadata.html) for
   * more information.
   */

  /**
   * Set the subject area of a source image.
   *
   * The [subject area of an image](https://rokka.io/documentation/references/dynamic-metadata.html#subject-area) is
   * used when applying the [crop operation](https://rokka.io/documentation/references/operations.html#crop) with the
   * `auto` anchor to center the cropping box around the subject area.
   *
   * ```js
   * rokka.sourceimages.setSubjectArea('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a', {
   *   x: 100,
   *   y: 100,
   *   width: 50,
   *   height: 50
   * },
   * {
   *   deletePrevious: false
   * }).then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @param {string} organization  name
   * @param {string} hash          image hash
   * @param {{width: number, height: number, x: number, y: number}} coords x, y starting from top left
   * @param {{deletePrevious: bool}} [options={}] Optional: only {deletePrevious: true/false} yet, false is default
   * @returns {Promise}
   */
  sourceimages.setSubjectArea = (organization, hash, coords, options = {}) => {
    options.deletePrevious = options.deletePrevious ? 'true' : 'false';

    return state.request(
      'PUT',
      'sourceimages/' +
        organization +
        '/' +
        hash +
        '/meta/dynamic/subject_area',
      coords,
      options
    )
  };

  /**
   * Removes the subject area from a source image.
   *
   * ```js
   * rokka.sourceimages.removeSubjectArea('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @param {string} organization
   * @param {string} hash
   * @param {{deletePrevious: bool}} [options={}] Optional: only {deletePrevious: true/false} yet, false is default
   * @return {Promise}
   */
  sourceimages.removeSubjectArea = (organization, hash, options = {}) => {
    options.deletePrevious = options.deletePrevious ? 'true' : 'false';

    return state.request(
      'DELETE',
      `sourceimages/${organization}/${hash}/meta/dynamic/subject_area`,
      null,
      options
    )
  };

  /**
   * ### User metadata
   *
   * See [the user metadata documentation](https://rokka.io/documentation/references/user-metadata.html)
   * for more information.
   */

  /**
   * Add user metadata to a source image.
   *
   * See [the user metadata documentation](https://rokka.io/documentation/references/user-metadata.html)
   * for an explanation.
   *
   * ```js
   * rokka.sourceimages.meta.add('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a', {
   *   somefield: 'somevalue',
   *   'int:some_number': 0,
   *   'delete_this': null
   * }).then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param {string} organization name
   * @param {string} hash         image hash
   * @param {object} data         metadata to add to the image
   * @return {Promise}
   */
  sourceimages.meta.add = (organization, hash, data) => {
    return state.request(
      'PATCH',
      `sourceimages/${organization}/${hash}/meta/user`,
      data
    )
  };

  /**
   * Replace user metadata of a source image with the passed data.
   *
   * See [the user metadata documentation](https://rokka.io/documentation/references/user-metadata.html)
   * for an explanation.
   *
   * ```js
   * rokka.sourceimages.meta.replace('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a', {
   *   somefield: 'somevalue',
   *   'int:some_number': 0
   * }).then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param {string} organization name
   * @param {string} hash         image hash
   * @param {object} data         new metadata
   * @return {Promise}
   */
  sourceimages.meta.replace = (organization, hash, data) => {
    return state.request(
      'PUT',
      `sourceimages/${organization}/${hash}/meta/user`,
      data
    )
  };

  /**
   * Replace user metadata of a source image with the passed data.
   *
   * See [the user metadata documentation](https://rokka.io/documentation/references/user-metadata.html)
   * for an explanation.
   *
   * ```js
   * rokka.sourceimages.meta.delete('myorg', 'c421f4e8cefe0fd3aab22832f51e85bacda0a47a')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * If the third parameter (field) is specified, it will just delete this field.
   *
   * @authenticated
   * @param {string} organization name
   * @param {string} hash         image hash
   * @param {string} [field=null] optional field to delete
   * @return {Promise}
   */
  sourceimages.meta.delete = (organization, hash, field = null) => {
    const fieldpath = field ? `/${field}` : '';
    return state.request(
      'DELETE',
      `sourceimages/${organization}/${hash}/meta/user${fieldpath}`
    )
  };

  return {
    sourceimages
  }
};

/**
 * ### Stack options
 *
 * @module stackoptions
 */
var stackoptions = state => {
  const stackoptions = {};

  /**
   * Returns a json-schema like definition of options which can be set on a stack.
   *
   * ```js
   * rokka.stackoptions.get()
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @return {Promise}
   */
  stackoptions.get = () => {
    return state.request('GET', 'stackoptions', null, null, {
      noAuthHeaders: true
    })
  };

  return {
    stackoptions
  }
};

/**
 * ### Stacks
 *
 * @module stacks
 */
var stacks = state => {
  const stacks = {};

  /**
   * Get a list of available stacks.
   *
   * ```js
   * rokka.stacks.list('myorg')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization  name
   * @param  {number}  [limit=null]
   * @param  {string}  [offset=null] cursor
   * @return {Promise}
   */
  stacks.list = (organization, limit = null, offset = null) => {
    const queryParams = {};

    if (limit !== null) {
      queryParams.limit = limit;
    }
    if (offset !== null) {
      queryParams.offset = offset;
    }

    return state.request('GET', `stacks/${organization}`, null, queryParams)
  };

  /**
   * Get details about a stack.
   *
   * ```js
   * rokka.stacks.get('myorg', 'mystack')
   *   .then(function(result) {})
   *   .catch(function(result) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  name         stack name
   * @return {Promise}
   */
  stacks.get = (organization, name) => {
    return state.request('GET', `stacks/${organization}/${name}`)
  };

  /**
   * Create a new stack.
   *
   * The signature of this method changed in 0.27.
   *
   * Using a single stack operation object (without an enclosing array) as the 3rd parameter (stackConfig) is
   *  since version 0.27.0 not supported anymore.
   *
   * ```js
   * const operations = [
   *   rokka.operations.rotate(45),
   *   rokka.operations.resize(100, 100)
   * ]
   *
   * // stack options are optional
   * const options = {
   *   'jpg.quality': 80,
   *   'webp.quality': 80
   * }
   *
   * // stack expressions are optional
   * const expressions = [
   *   rokka.expressions.default('options.dpr > 2', { 'jpg.quality': 60, 'webp.quality': 60 })
   * ]
   *
   * // query params are optional
   * var queryParams = { overwrite: true }
   * rokka.stacks.create(
   *   'test',
   *   'mystack',
   *   { operations, options, expressions },
   *   queryParams
   * ).then(function(result) {})
   *  .catch(function(err) {})
   * ```
   *
   * @authenticated
   * @param  {string}       organization name
   * @param  {string}       name         stack name
   * @param  {Object}       stackConfig  object with the stack config of stack operations, options and expressions.
   * @param  {{overwrite: bool}} [params={}]  params       query params, only {overwrite: true|false} is currently supported
   * @return {Promise}
   */

  stacks.create = (organization, name, stackConfig, params = {}, ...rest) => {
    let queryParams = Object.assign({}, params);
    let body = {};

    // backwards compatibility for previous signature:
    // create(organization, name, operations, options = null, overwrite = false)
    if (Array.isArray(stackConfig)) {
      body.operations = stackConfig;
      body.options = params;
      const _overwrite = rest.length > 0 ? rest[0] : false;
      queryParams = {};
      if (_overwrite) {
        queryParams.overwrite = _overwrite;
      }
    } else {
      body = stackConfig;
    }

    return state.request(
      'PUT',
      `stacks/${organization}/${name}`,
      body,
      queryParams
    )
  };

  /**
   * Delete a stack.
   *
   * ```js
   * rokka.stacks.delete('myorg', 'mystack')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @authenticated
   * @param  {string}  organization name
   * @param  {string}  name         stack name
   * @return {Promise}
   */
  stacks.delete = (organization, name) => {
    return state.request('DELETE', `stacks/${organization}/${name}`)
  };

  return {
    stacks
  }
};

/**
 * ### Stats
 *
 * @module stats
 */
var stats = state => {
  const stats = {};

  /**
   * Retrieve statistics about an organization.
   *
   * If `from` and `to` are not specified, the API will return data for the last 30 days.
   *
   * ```js
   * rokka.stats.get('myorg', '2017-01-01', '2017-01-31')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @param {string} organization name
   * @param {string} [from=null]  date in format YYYY-MM-DD
   * @param {string} [to=null]    date in format YYYY-MM-DD
   *
   * @return {Promise}
   */
  stats.get = (organization, from = null, to = null) => {
    return state.request('GET', `stats/${organization}`, null, {
      from,
      to
    })
  };

  return {
    stats
  }
};

/**
 * ### Billing
 *
 * @module billing
 */
var billing = state => {
  const billing = {};

  /**
   * Retrieve statistics about the billing of an organization
   *
   * If `from` and `to` are not specified, the API will return data for the last 30 days.
   *
   * ```js
   * rokka.billing.get('myorg', '2017-01-01', '2017-01-31')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @param {string} organization name
   * @param {string} [from=null]  date in format YYYY-MM-DD
   * @param {string} [to=null]    date in format YYYY-MM-DD
   *
   * @return {Promise}
   */
  billing.get = (organization, from = null, to = null) => {
    return state.request('GET', `billing/${organization}`, null, {
      from,
      to
    })
  };

  return {
    billing
  }
};

/**
 * ### Users
 *
 * @module users
 */
var users = state => {
  const users = {};

  /**
   * Register a new user for the rokka service.
   *
   * ```js
   * rokka.users.create('user@example.org')
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @param {string} email address of a user
   * @param {string} [organization = null] to create
   * @return {Promise}
   */
  users.create = (email, organization = null) => {
    return state.request('POST', 'users', { email, organization }, null, {
      noAuthHeaders: true
    })
  };

  /**
   * Get user_id for current user
   *
   * ```js
   * rokka.users.getId()
   *   .then(function(result) {})
   *   .catch(function(err) {});
   * ```
   *
   * @return {Promise}
   */
  users.getId = () => {
    return state.request('GET', 'user').then(result => result.body.user_id)
  };

  return {
    users
  }
};

var modules = state => {
  return Object.assign(
    {},
    memberships(state),
    operations(state),
    organizations(state),
    expressions(),
    render(state),
    sourceimages(state),
    stackoptions(state),
    stacks(state),
    stats(state),
    users(state),
    billing(state)
  )
};

var RokkaResponse = (originalResponse = {}) => {
  const response = {
    response: originalResponse,
    body: null,
    get statusCode () {
      return this.response.status
    },
    get statusMessage () {
      return this.response.statusText
    }
  };
  return response
};

const defaults = {
  apiHost: 'https://api.rokka.io',
  renderHost: 'https://{organization}.rokka.io',
  apiVersion: 1,
  transport: {
    requestTimeout: 30000,
    retries: 10,
    minTimeout: 1000,
    maxTimeout: 10000,
    randomize: true,
    factor: 2
  }
};

const getResponseBody = async response => {
  if (response.headers && response.json) {
    if (response.headers.get('content-type') === 'application/json') {
      return response.json()
    }
    return response.text()
  }
  return response.body
};
/**
 * Initializing the rokka client.
 *
 * ```js
 * const rokka = require('rokka')({
 *   apiKey: 'apikey',       // required for certain operations
 *   apiHost: '<url>',       // default: https://api.rokka.io
 *   apiVersion: <number>,   // default: 1
 *   renderHost: '<url>',    // default: https://{organization}.rokka.io
 *   debug: true,            // default: false
 *   transport: {
 *     requestTimeout: <number>,  // milliseconds to wait for rokka server response (default: 30000)
 *     retries: <number>,         // number of retries when API response is 429 (default: 10)
 *     minTimeout: <number>,      // minimum milliseconds between retries (default: 1000)
 *     maxTimeout: <number>,      // maximum milliseconds between retries (default: 10000)
 *     randomize: <boolean>       // randomize time between retries (default: true)
 *   }
 * });
 * ```
 *
 * All properties are optional since certain calls don't require credentials.
 *
 * @param  {Object} [config={}] configuration properties
 * @return {Object}
 *
 * @module rokka
 */
var index = (config = {}) => {
  if (config.debug !== null) {
    transport.debug = config.debug;
  }

  const state = {
    // config
    apiKey: config.apiKey,
    apiHost: config.apiHost || defaults.apiHost,
    apiVersion: config.apiVersion || defaults.apiVersion,
    renderHost: config.renderHost || defaults.renderHost,
    transportOptions: Object.assign(defaults.transport, config.transport),

    // functions
    request (method, path, payload = null, queryParams = null, options = {}) {
      let uri = [state.apiHost, path].join('/');
      if (
        queryParams &&
        !(
          Object.entries(queryParams).length === 0 &&
          queryParams.constructor === Object
        )
      ) {
        uri += '?' + queryString.stringify(queryParams);
      }
      const headers = options.headers || {};

      headers['Api-Version'] = state.apiVersion;

      if (options.noAuthHeaders !== true) {
        if (!state.apiKey) {
          return Promise.reject(new Error('Missing required property `apiKey`'))
        }

        headers['Api-Key'] = state.apiKey;
      }

      const retryDelay = (attempt, error, response) => {
        // from https://github.com/tim-kos/node-retry/blob/master/lib/retry.js
        const random = state.transportOptions.randomize ? Math.random() + 1 : 1;

        const timeout = Math.round(
          random *
            state.transportOptions.minTimeout *
            Math.pow(state.transportOptions.factor, attempt)
        );
        return Math.min(timeout, state.transportOptions.maxTimeout)
      };

      const request = {
        method: method,
        headers: headers,
        timeout: state.transportOptions.requestTimeout,
        retries: state.transportOptions.retries,
        retryDelay
      };
      if (options.form === true) {
        const formData = payload || {};
        const requestData = new FormData();
        Object.keys(formData).forEach(function (meta) {
          requestData.append(meta, formData[meta]);
        });
        request.body = requestData;
      } else if (options.multipart !== true) {
        request.json = true;
        request.body = payload;
      } else {
        const formData = payload.formData || {};
        const requestData = new FormData();

        requestData.append(payload.name, payload.contents, payload.filename);

        Object.keys(formData).forEach(function (meta) {
          requestData.append(meta, JSON.stringify(formData[meta]));
        });

        request.body = requestData;
      }

      if (request.json && request.body && typeof request.body === 'object') {
        request.body = JSON.stringify(request.body);
      }

      const t = transport(uri, request);
      return t.then(async response => {
        const rokkaResponse = RokkaResponse(response);
        rokkaResponse.body = await getResponseBody(response);
        if (response.status >= 400) {
          rokkaResponse.error = rokkaResponse.body;
          rokkaResponse.message =
            response.status + ' - ' + JSON.stringify(rokkaResponse.body);
          throw rokkaResponse
        }
        return rokkaResponse
      })
    }
  };

  return Object.assign({}, modules(state))
};

module.exports = index;
